[C++程序设计](https://www.bilibili.com/video/av6892144?p=2)
### 函数指针 Function pointer
* 用起来和函数名一样，有什么意义？
* 事先不知道函数名，可以先定义一个函数指针占位
* 比如排序算法的比较函数

### 引用 Reference
* 引用以后，完全等价
* 必须初始化，且初始化后不能改变
* 有什么用？
    * 交换函数：C 必须用指针传递参数实现（ugly），C++ 可以用引用传递参数实现
    * 引用作为函数返回值，用处？以后再说
* 常引用：不能通过常引用去修改引用的变量

### Const 关键字
* 定义常量：多用 const，少用 define。因为 const 有类型，便于类型检查。
* 定义常量指针：不能通过常量指针修改其指向的内容，但可以修改常量指针的指向
    * 用处：函数传递参数定义为常量指针，可以避免修改指向地址的内容
* 定义常引用

### 动态内存分配 Dynamic 有什么用？？？
* 返回类型是指针： T *
* new T : T 是一个类型，比如int
* new T[N]
* 用完必须删除
    * delete p
    * delete [] p : 否则释放不完全

### 内联函数 
* 函数名前面加 inline
* 为了减少调用函数的开销，C++ 效率狂魔
* 弊端：可能增加编译后的代码量，即可执行程序 exe 体积增大！

### 函数重载
* 名字相同，参数表不同
* C 不能用相同的名字，C++ 可以：编译器根据参数的类型和个数匹配
* 使函数名字简单好记
* 注意参数二义性会报错

### 函数的缺省参数
* 只能从最右边连续缺省
* 意义：提高程序可扩充性，少修改代码

## 类
### 定义
* 定义： 注意要有`分号；`
* `class 类名 {};`
### 访问成员变量和成员函数
* 对象名.成员名
* 指针->成员名
* 引用名.成员名
### 成员函数在类外定义
* 在类内只声明函数：`int 函数名()`
* 在类外定义，函数名要改为`类名::函数名`
### 类成员的可访问范围
* private : 缺省则默认 private
* public
* protected ：在继承中讲
### 内联成员函数
* inline + 成员函数
* 整个函数体出现在类定义内部（熟悉的方式）
### 成员函数也可以重载和缺省参数
* 使用参数缺省又使用重载：要避免二义性
### 构造函数
* 不能有返回值，void也不行
* 构造函数不负责给类里面的成员变量分配空间（造房子），只是用来初始化（装修）
* 没有定义的话，编译器生成一个没有参数的构造函数，啥也不干。
* 生成对象自动调用
* 意义：初始化工作不怕忘
* 可以重载！
* 对象数组的初始化
    * 类名 对象名[2] = {第一个构造函数的参数, 第二个构造函数的参数}
    * 缺省将使用缺省参数的构造函数，前提是之前定义了，不然报错
    ```cpp
    class Test {
        public:
            Test(int n) {}
            Test(int n, int m) {}
            Test() {}
    };
    Test array[3] = {1, Test(1,2)};
    // 分别使用了三个构造函数
    Test * pArray[3] = {new Test(4), new Test(1,2)}; // 指针数组
    ```
### 复制构造函数 copy constructor
* 编译器默认生成
* 只有一个参数：同类对象的引用
```cpp
class Complex {
    public:
        double real, imag;
        Complex() {};
        Complex(const Complex & c) {
            real = c.real;
            imag = c.imag;
        } 
};
Complex c1;
Complex c2(c1); // 等价形式 Complex c2 = c1;  
```
* 起作用的三种情况
    * 初始化 
        * `Complex c2(c1)`或者`Complex c2 = c1`，注意不是赋值语句
        * `c2 = c1`是赋值语句，不是初始化，不存在调用构造函数
    * 对象作为函数参数
    ```cpp
    void Func(A a1) {}
    int main() {
        A a2;
        Func(a2);
        return 0;
    }
    ```
    * 对象作为函数返回值
    ```cpp
    A Func() {
        A b();
        return b;
    }
    int main() {
        cout << Func().v <<end;
        return 0;
    }
    ```
* 自己定义，可以不做复制的工作
    * 可以使形参不等于实参！
    * 也可以使函数返回值不等于你想要的那个！
* 那为什么要自己写复制构造函数？？？
    * 下回分解：
    * 情况1：需要在所有构造函数里增加一个静态成员时

### 类型转换构造函数 type conversion
* 只有一个参数
* 不是复制构造函数
* 编译时自动调用的话，会建立一个临时变量
```cpp
class Complex {
    public:
        double real, imag;
        Complex(int i) { // this is 类型转换构造函数
            real = i;
            imag = 0;
        }
        Complex(double r, double i) {
            real = r; imag = i;
        }
};
int main() {
    Complex c1(7,8);
    Complex c2 = 12; // 人为调用：不会生成临时对象，= 是初始化，不是赋值
    c1 = 9; // 编译器自动调用：9被构造成一个临时的Complex对象，= 是赋值
}
```
### 析构函数 destructor
* ~ 类名()
* 没有参数没有返回值
* 没写，编译器会生成缺省的析构函数，但不会释放 new 生成的空间
* 作用域
    * 跃出作用于，会调用 destructor
```cpp
int main {
    ...
    { Demo d5(5); }
    ...
}
```
* 先被构造的，最后被析构
### 静态成员 static member
* 变量
    * 所有对象共享一个
    * sizeof 不会计算静态成员变量，因为不是放在对象内部
* 函数
    * 并不具体作用于某个对象
    * 类名::成员函数名
    * 对象名.成员函数名
    * 指针 -> 成员函数名
    * 引用.成员函数名
    * 第二三四虽然这样写，并不作用于某个对象
    * 成员函数换成成员变量也适用
    * 本质是全局变量，全局函数，为什么不直接写全局的呢？
        * 目的：将与某些类紧密相关的全局变量和函数写到类里面，看上去是一个整体，便于理解和维护！
        * 比如：矩形类，求举行总数和总面积，其他三角形类不能访问
* 静态成员变量要拿出来单独声明一下，可以不初始化
    * 否则编译能通过，链接不能通过？？
* 注意！在静态成员函数中，不能访问非静态的成员变量，也不能调用非静态成员函数！
    * 因为静态成员函数不是作用在对象上的！










